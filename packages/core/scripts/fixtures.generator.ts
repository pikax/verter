/**
 * Fixtures Generator Script
 *
 * This script finds all *.fixtures.ts files in the source directory
 * and generates corresponding type fixture files for IDE inspection.
 *
 * Run with: pnpm generate:fixtures
 *
 * Generated files are placed in __generated__ folders next to the fixture definitions.
 */

import { globSync } from "glob";
import { writeFileSync, mkdirSync, existsSync, rmSync } from "node:fs";
import path from "node:path";
import { pathToFileURL } from "node:url";

const ROOT_DIR = path.resolve(__dirname, "..");
const SRC_DIR = path.join(ROOT_DIR, "src");
const SHOULD_INCLUDE_ANNOTATIONS = process.argv.includes("--annotations");

interface Fixture {
  name: string;
  code: string;
  lang?: string;
  generic?: string;
  expectations?: any;
}

interface FixtureConfig {
  fixtures: Fixture[];
  process: (code: string, lang?: string, generic?: string) => { result: string; context?: any; sourcemap?: string };
  prefix?: string;
}

/**
 * Format code for better readability
 */
function formatForReadability(code: string): string {
  return code
    .replace(/(}|>|\)|;)\s*;(const|let|type)/g, "$1;\n$2")
    .replace(/\n\n+/g, "\n");
}

/**
 * Add twoslash annotations for IDE type hints
 * Adds ^? on result variables and on macro function calls
 */
function addTwoslashAnnotations(code: string, prefix: string): string {
  const formatted = formatForReadability(code);
  const lines = formatted.split("\n");
  const result: string[] = [];

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    // Check for variable declaration with macro call: const varName = defineMacro...
    const varWithMacroMatch = line.match(
      /(const|let)\s+(\w+)\s*=\s*(defineProps|defineEmits|defineModel|defineSlots|defineExpose|withDefaults)/
    );

    if (varWithMacroMatch) {
      const [, keyword, varName, macroName] = varWithMacroMatch;

      // Only annotate user-facing variables (not prefixed internal ones)
      if (!prefix || !varName.startsWith(prefix)) {
        // Split the line to put ^? annotations on separate lines
        const keywordStart = line.indexOf(keyword);
        const varStart = line.indexOf(varName, keywordStart);

        // Add annotation for the variable
        const varSpaces = " ".repeat(varStart);
        result.push(`${keyword} ${varName} =`);
        result.push(`${varSpaces}//^?`);

        // Add the rest of the line (the macro call) with consistent indentation
        const restOfLine = line.slice(line.indexOf("=") + 1).trim();
        const indent = "  "; // Use standard indentation for the macro call
        result.push(`${indent}${restOfLine}`);
        result.push(`${indent}//^?`);
        continue;
      }
    }

    // Check for standalone macro calls (like defineExpose without assignment)
    const standaloneMacroMatch = line.match(
      /^\s*(defineProps|defineEmits|defineModel|defineSlots|defineExpose|withDefaults)\s*[<(]/
    );
    if (standaloneMacroMatch && !line.includes("=")) {
      const macroName = standaloneMacroMatch[1];
      const macroStart = line.indexOf(macroName);
      const spaces = " ".repeat(macroStart);
      result.push(line);
      result.push(`${spaces}//^?`);
      continue;
    }

    result.push(line);
  }

  return result.join("\n");
}

/**
 * Generate header for fixture files
 */
function generateHeader(): string {
  return `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * 
 * This file is generated by scripts/fixtures.generator.ts
 * Open this file in VS Code to inspect types with hover.
 * 
 * Install the "Twoslash Query Comments" extension for inline type hints:
 * https://marketplace.visualstudio.com/items?itemName=Orta.vscode-twoslash-queries
 * 
 * Run: pnpm generate:fixtures
 */
`;
}

/**
 * Generate a single fixture block
 */
function generateFixtureBlock(
  fixture: Fixture,
  output: string,
  prefix: string,
  sourcemap?: string,
  includeAnnotations: boolean = true
): string {
  const annotatedOutput = includeAnnotations
    ? addTwoslashAnnotations(output, prefix)
    : formatForReadability(output);
  const lang = fixture.lang || "ts";
  const genericAttr = fixture.generic ? ` generic="${fixture.generic}"` : "";
  const sourcemapComment = sourcemap
    ? `\n//# sourceMappingURL=${sourcemap}`
    : "";

  return `
// ============================================================================
// ${fixture.name}
// ============================================================================
/*
Original:
\`\`\`vue
<script setup lang="${lang}"${genericAttr}>${fixture.code}</script>
\`\`\`
*/

// Transformed output:
${annotatedOutput}${sourcemapComment}
`;
}

/**
 * Process a single fixture file
 */
async function processFixtureFile(fixtureFilePath: string): Promise<void> {
  console.log(`\nProcessing: ${path.relative(ROOT_DIR, fixtureFilePath)}`);

  try {
    // Import the fixture module
    const fileUrl = pathToFileURL(fixtureFilePath).href;
  const fixtureModule = await import(fileUrl);

    if (typeof fixtureModule.createFixtures !== "function") {
      console.log(`  Skipping: No createFixtures export found`);
      return;
    }

    const config: FixtureConfig = fixtureModule.createFixtures();
    const prefix = config.prefix ?? "___VERTER___";

    // Create __generated__ directory (clean it first if it exists)
    const fixtureDir = path.dirname(fixtureFilePath);
    const generatedDir = path.join(fixtureDir, "__generated__");

    if (existsSync(generatedDir)) {
      rmSync(generatedDir, { recursive: true });
    }
    mkdirSync(generatedDir, { recursive: true });

    // Write global.d.ts for $verter/types$ module resolution
    const globalDtsFile = path.join(generatedDir, "global.d.ts");
    const globalDtsContent = `declare module "$verter/types$" {
  export * from "@verter/types";
}
`;
    writeFileSync(globalDtsFile, globalDtsContent);
    console.log(`  Generated: global.d.ts`);

    // Generate individual fixture files
    const sections: string[] = [generateHeader()];

    for (const fixture of config.fixtures) {
      try {
        const { result, sourcemap } = config.process(
          fixture.code,
          fixture.lang,
          fixture.generic
        );
        const block = generateFixtureBlock(
          fixture,
          result,
          prefix,
          sourcemap,
          SHOULD_INCLUDE_ANNOTATIONS
        );
        sections.push(block);

        // Also create individual file for each fixture
        const safeName = fixture.name
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, "-")
          .replace(/^-|-$/g, "");
        const individualFile = path.join(generatedDir, `${safeName}.ts`);
        writeFileSync(individualFile, generateHeader() + block);
        console.log(`  Generated: ${safeName}.ts`);
      } catch (error) {
        console.error(`  Error processing fixture "${fixture.name}":`, error);
        sections.push(`
// ============================================================================
// ${fixture.name}
// ============================================================================
// ERROR: ${error instanceof Error ? error.message : String(error)}
`);
      }
    }

    // Write tsconfig.json for the __generated__ folder so VS Code picks it up
    const tsconfigFile = path.join(generatedDir, "tsconfig.json");
    const tsconfigContent = JSON.stringify(
      {
        compilerOptions: {
          target: "ESNext",
          module: "ESNext",
          moduleResolution: "bundler",
          strict: true,
          skipLibCheck: true,
          noEmit: true,
          esModuleInterop: true,
          allowSyntheticDefaultImports: true,
          lib: ["ESNext", "DOM"],
          types: [],
        },
        include: ["./*.ts"],
      },
      null,
      2
    );
    writeFileSync(tsconfigFile, tsconfigContent);
    console.log(`  Generated: tsconfig.json`);
  } catch (error) {
    console.error(`  Error loading fixture file:`, error);
  }
}

/**
 * Main entry point
 */
async function main(): Promise<void> {
  console.log("=== Fixtures Generator ===");
  console.log(`Source directory: ${SRC_DIR}`);

  // Find all *.fixtures.ts files
  const fixtureFiles = globSync("**/*.fixtures.ts", {
    cwd: SRC_DIR,
    absolute: true,
    ignore: ["**/node_modules/**", "**/__generated__/**"],
  });

  if (fixtureFiles.length === 0) {
    console.log("\nNo fixture files found.");
    return;
  }

  console.log(`\nFound ${fixtureFiles.length} fixture file(s)`);

  // Process each fixture file
  for (const fixtureFile of fixtureFiles) {
    await processFixtureFile(fixtureFile);
  }

  console.log("\n=== Done ===");
}

main().catch(console.error);
