/**
 * Shared types and utilities for fixture-based type testing.
 * 
 * This module provides the foundation for creating type fixtures
 * that can be:
 * 1. Generated as standalone .ts files for IDE inspection
 * 2. Used in vitest spec files for automated testing
 * 
 * Usage:
 * 1. Create a `*.fixtures.ts` file in your plugin folder
 * 2. Export a `createFixtures` function that returns FixtureConfig
 * 3. Run `pnpm generate:fixtures` to generate the fixture files
 */

/**
 * A single test fixture definition
 */
export interface Fixture {
  /** Descriptive name for the fixture */
  name: string;
  /** Vue SFC script setup content (without <script> tags) */
  code: string;
  /** Language for the script block */
  lang?: "ts" | "js" | "tsx" | "jsx";
  /** Expected patterns to verify in the output */
  expectations?: FixtureExpectations;
}

/**
 * Expected patterns for validating fixture output
 */
export interface FixtureExpectations {
  /** Type aliases that should be created */
  typeAliases?: string[];
  /** Boxed variables that should be created */
  boxedVariables?: string[];
  /** Patterns that should appear in the output */
  patterns?: string[];
  /** Patterns that should NOT appear in the output */
  antiPatterns?: string[];
}

/**
 * Configuration for a fixture file
 */
export interface FixtureConfig {
  /** Fixtures to generate */
  fixtures: Fixture[];
  /** 
   * Process function to transform Vue SFC content
   * This should return the transformed result string
   */
  process: (code: string, lang?: string) => ProcessResult;
  /** 
   * Optional prefix for helper types.
   * Set to '' to disable prefixing for cleaner output.
   * @default '___VERTER___'
   */
  prefix?: string;
}

/**
 * Result from processing a fixture
 */
export interface ProcessResult {
  /** The transformed code result */
  result: string;
  /** Optional context with additional processing info */
  context?: {
    items: any[];
    [key: string]: any;
  };
}

/**
 * Result from running a fixture through the pipeline
 */
export interface FixtureResult {
  /** The fixture definition */
  fixture: Fixture;
  /** The processed output */
  output: string;
  /** Whether processing was successful */
  success: boolean;
  /** Error message if processing failed */
  error?: string;
}

/**
 * Header content for generated fixture files
 */
export function createFixtureHeader(prefix: string = ""): string {
  const importStatement = prefix 
    ? `import type * as VerterTypes from "@verter/types";\n\n// Re-export with prefix for type resolution\ntype ${prefix}Prettify<T> = VerterTypes.Prettify<T>;\n// ... other type aliases would go here`
    : `import type * as VerterTypes from "@verter/types";`;

  return `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * 
 * This file is generated by the fixtures generator.
 * Open this file in VS Code to inspect types with hover.
 * 
 * Install the "Twoslash Query Comments" extension for inline type hints:
 * https://marketplace.visualstudio.com/items?itemName=Orta.vscode-twoslash-queries
 * 
 * Run: pnpm generate:fixtures
 */

/* eslint-disable */

import type { Ref, ComputedRef, ModelRef, WritableComputedRef } from 'vue';
import { ref, computed, defineProps, defineEmits, defineModel, defineSlots, defineExpose, withDefaults } from 'vue';
${importStatement}

`;
}

/**
 * Format code for better readability in generated fixtures
 */
export function formatForReadability(code: string): string {
  return code
    // Split after closing brace/parenthesis + semicolon before statement start
    .replace(/(}|>|\)|;)\s*;(const|let|type)/g, '$1;\n$2')
    // Clean up double newlines
    .replace(/\n\n+/g, '\n');
}

/**
 * Add twoslash query annotations for IDE type inspection
 */
export function addTwoslashAnnotations(code: string): string {
  const formatted = formatForReadability(code);
  const lines = formatted.split("\n");
  const result: string[] = [];
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    result.push(line);
    
    // Add ^? annotation after variable declarations
    const inlineVarMatch = line.match(/(const|let)\s+(\w+)\s*=/);
    if (inlineVarMatch) {
      const [fullMatch, , varName] = inlineVarMatch;
      // Only annotate user-facing variables
      if (!varName.startsWith("___VERTER___")) {
        const varStart = line.indexOf(fullMatch) + fullMatch.indexOf(varName);
        const spaces = " ".repeat(varStart);
        result.push(`${spaces}//${"^".repeat(varName.length)}?`);
      }
    }
    
    // Add ^? annotation after standalone type alias declarations
    const standaloneTypeMatch = line.match(/^(\s*)type\s+(___VERTER___\w+)\s*=/);
    if (standaloneTypeMatch) {
      const [, , typeName] = standaloneTypeMatch;
      const typeStart = line.indexOf(typeName);
      const spaces = " ".repeat(typeStart);
      result.push(`${spaces}//${"^".repeat(Math.min(typeName.length, 30))}?`);
    }
  }
  
  return result.join("\n");
}

/**
 * Generate a single fixture block for the output file
 */
export function generateFixtureBlock(
  fixture: Fixture,
  output: string,
  includeAnnotations: boolean = true
): string {
  const processedOutput = includeAnnotations 
    ? addTwoslashAnnotations(output)
    : formatForReadability(output);

  return `
// ============================================================================
// ${fixture.name}
// ============================================================================
/*
Original:
\`\`\`vue
<script setup lang="${fixture.lang || 'ts'}">${fixture.code}</script>
\`\`\`
*/

// Transformed output:
{
${processedOutput.split("\n").map((l: string) => `  ${l}`).join("\n")}
}
`;
}
