import { MagicString } from "@vue/compiler-sfc";
import { parser } from "../../../../parser";
import { ParsedBlockScript } from "../../../../parser/types";
import { processScript } from "../../script";

import { MacrosPlugin } from "./index.js";
import { TemplateBindingPlugin } from "../template-binding";
import { ScriptBlockPlugin } from "../script-block";
import { BindingPlugin } from "../binding";

import * as ts from "typescript";
import { fixtures, createFixtures } from "./macros.fixtures";
import type { Fixture } from "../../../../../fixtures/types";

/**
 * Type structure tests for the macros plugin output.
 * 
 * These tests validate that the TypeScript types generated by the macro transformations
 * have the correct structure. We use AST analysis to verify:
 * - Type declarations are created with correct names
 * - Boxed variables preserve the original type structure
 * - Prettify wrapper is applied correctly
 * - Generated code is syntactically valid TypeScript
 * 
 * For visual type inspection, run: pnpm generate:fixtures
 * Then open __generated__/_all.ts in VS Code
 */

const PREFIX = "___VERTER___";

// Get the process function from fixtures
const fixtureConfig = createFixtures();
const processMacros = fixtureConfig.process;

// Parse Vue SFC and get transformed result
function parseVueSFC(
  content: string,
  lang = "ts"
): { result: string; context: any } {
  const result = processMacros(content, lang);
  return {
    result: result.result,
    context: result.context,
  };
}

// Parse TypeScript source code into an AST
function parseTypeScript(code: string): ts.SourceFile {
  return ts.createSourceFile(
    "test.ts",
    code,
    ts.ScriptTarget.Latest,
    true,
    ts.ScriptKind.TS
  );
}

// Find all type alias declarations in the AST
function findTypeAliases(sourceFile: ts.SourceFile): Map<string, ts.TypeAliasDeclaration> {
  const aliases = new Map<string, ts.TypeAliasDeclaration>();
  
  function visit(node: ts.Node) {
    if (ts.isTypeAliasDeclaration(node)) {
      aliases.set(node.name.text, node);
    }
    ts.forEachChild(node, visit);
  }
  
  ts.forEachChild(sourceFile, visit);
  return aliases;
}

// Find all variable declarations in the AST
function findVariableDeclarations(sourceFile: ts.SourceFile): Map<string, ts.VariableDeclaration> {
  const declarations = new Map<string, ts.VariableDeclaration>();
  
  function visit(node: ts.Node) {
    if (ts.isVariableDeclaration(node) && ts.isIdentifier(node.name)) {
      declarations.set(node.name.text, node);
    }
    ts.forEachChild(node, visit);
  }
  
  ts.forEachChild(sourceFile, visit);
  return declarations;
}

// Check if code has syntax errors
function hasSyntaxErrors(sourceFile: ts.SourceFile): ts.Diagnostic[] {
  // Use the built-in syntax diagnostic check (parseDiagnostics is internal)
  return (sourceFile as any).parseDiagnostics || [];
}

// Helper to get fixture by name
function getFixture(name: string): Fixture {
  const fixture = fixtures.find(f => f.name === name);
  if (!fixture) throw new Error(`Fixture not found: ${name}`);
  return fixture;
}

describe("macros type structure tests", () => {
  describe("syntax validation", () => {
    it("should generate syntactically valid TypeScript for defineProps<T>()", () => {
      const { result } = parseVueSFC(`
const props = defineProps<{ msg: string }>()
`);

      const sourceFile = parseTypeScript(result);
      const errors = hasSyntaxErrors(sourceFile);
      
      if (errors.length > 0) {
        console.log("Syntax errors:", errors.map(e => e.messageText));
        console.log("Generated code:", result);
      }
      
      expect(errors).toHaveLength(0);
    });

    it("should generate syntactically valid TypeScript for defineProps({})", () => {
      const { result } = parseVueSFC(`
const props = defineProps({ foo: String, bar: Number })
`);

      const sourceFile = parseTypeScript(result);
      const errors = hasSyntaxErrors(sourceFile);
      
      expect(errors).toHaveLength(0);
    });

    it("should generate syntactically valid TypeScript for defineEmits<T>()", () => {
      const { result } = parseVueSFC(`
const emit = defineEmits<{ change: [value: string]; update: [id: number] }>()
`);

      const sourceFile = parseTypeScript(result);
      const errors = hasSyntaxErrors(sourceFile);
      
      expect(errors).toHaveLength(0);
    });

    it("should generate syntactically valid TypeScript for defineModel<T>()", () => {
      const { result } = parseVueSFC(`
const model = defineModel<string>()
`);

      const sourceFile = parseTypeScript(result);
      const errors = hasSyntaxErrors(sourceFile);
      
      expect(errors).toHaveLength(0);
    });

    it("should generate syntactically valid TypeScript for withDefaults", () => {
      const { result } = parseVueSFC(`
const props = withDefaults(defineProps<{ msg?: string }>(), { msg: 'hello' })
`);

      const sourceFile = parseTypeScript(result);
      const errors = hasSyntaxErrors(sourceFile);
      
      expect(errors).toHaveLength(0);
    });

    it("should generate syntactically valid TypeScript for complex props", () => {
      const { result } = parseVueSFC(`
interface User { name: string; age: number }
const props = defineProps<{ user: User; tags: string[] }>()
`);

      const sourceFile = parseTypeScript(result);
      const errors = hasSyntaxErrors(sourceFile);
      
      expect(errors).toHaveLength(0);
    });
  });

  describe("type alias structure - defineProps_Type", () => {
    it("should create type alias for defineProps with type argument", () => {
      const { result } = parseVueSFC(`
const props = defineProps<{ msg: string; count: number }>()
`);

      const sourceFile = parseTypeScript(result);
      const typeAliases = findTypeAliases(sourceFile);
      
      const propsType = typeAliases.get(`${PREFIX}defineProps_Type`);
      expect(propsType).toBeDefined();
      
      // The type should contain the original type content
      if (propsType) {
        const typeText = propsType.type.getText(sourceFile);
        // Should be wrapped in Prettify
        expect(typeText).toContain(`${PREFIX}Prettify`);
      }
    });

    it("should handle optional properties in type alias", () => {
      const { result } = parseVueSFC(`
const props = defineProps<{ msg?: string; count?: number }>()
`);

      expect(result).toContain(`type ${PREFIX}defineProps_Type`);
      expect(result).toContain("msg?:");
      expect(result).toContain("count?:");
    });

    it("should preserve complex types in type alias", () => {
      const { result } = parseVueSFC(`
interface User { name: string; age: number }
const props = defineProps<{ user: User; tags: string[] }>()
`);

      expect(result).toContain(`type ${PREFIX}defineProps_Type`);
      expect(result).toContain("user: User");
      expect(result).toContain("tags: string[]");
    });
  });

  describe("type alias structure - defineEmits_Type", () => {
    it("should create type alias for defineEmits with type argument", () => {
      const { result } = parseVueSFC(`
const emit = defineEmits<{ change: [value: string] }>()
`);

      const sourceFile = parseTypeScript(result);
      const typeAliases = findTypeAliases(sourceFile);
      
      const emitsType = typeAliases.get(`${PREFIX}defineEmits_Type`);
      expect(emitsType).toBeDefined();
    });

    it("should handle multiple events in type alias", () => {
      const { result } = parseVueSFC(`
const emit = defineEmits<{
  change: [value: string]
  update: [id: number, name: string]
  reset: []
}>()
`);

      expect(result).toContain(`type ${PREFIX}defineEmits_Type`);
      expect(result).toContain("change");
      expect(result).toContain("update");
      expect(result).toContain("reset");
    });
  });

  describe("type alias structure - defineModel_Type", () => {
    it("should create type alias for defineModel with type argument", () => {
      const { result } = parseVueSFC(`
const model = defineModel<string>()
`);

      // defineModel creates a prefixed type based on the model name
      expect(result).toContain(`type ${PREFIX}modelValue_defineModel_Type`);
    });

    it("should create named type alias for named defineModel", () => {
      const { result } = parseVueSFC(`
const title = defineModel<string>('title')
`);

      expect(result).toContain(`type ${PREFIX}title_defineModel_Type`);
    });

    it("should create separate type aliases for multiple models", () => {
      const { result } = parseVueSFC(`
const firstName = defineModel<string>('firstName')
const lastName = defineModel<string>('lastName')
`);

      expect(result).toContain(`type ${PREFIX}firstName_defineModel_Type`);
      expect(result).toContain(`type ${PREFIX}lastName_defineModel_Type`);
    });
  });

  describe("boxed variable structure", () => {
    it("should create boxed variable for defineProps with object", () => {
      const { result } = parseVueSFC(`
const props = defineProps({ foo: String, bar: Number })
`);

      const sourceFile = parseTypeScript(result);
      const declarations = findVariableDeclarations(sourceFile);
      
      const boxed = declarations.get(`${PREFIX}defineProps_Boxed`);
      expect(boxed).toBeDefined();
      
      // Should use the Box function
      expect(result).toContain(`${PREFIX}defineProps_Box(`);
      expect(result).toContain("foo: String");
      expect(result).toContain("bar: Number");
    });

    it("should create boxed variable for defineEmits with array", () => {
      const { result } = parseVueSFC(`
const emit = defineEmits(['change', 'update'])
`);

      const sourceFile = parseTypeScript(result);
      const declarations = findVariableDeclarations(sourceFile);
      
      const boxed = declarations.get(`${PREFIX}defineEmits_Boxed`);
      expect(boxed).toBeDefined();
      
      expect(result).toContain(`${PREFIX}defineEmits_Box(`);
      expect(result).toContain("'change'");
      expect(result).toContain("'update'");
    });

    it("should create boxed variable for withDefaults", () => {
      const { result } = parseVueSFC(`
const props = withDefaults(defineProps<{ msg?: string }>(), { msg: 'default' })
`);

      expect(result).toContain(`${PREFIX}withDefaults_Boxed`);
      expect(result).toContain(`${PREFIX}withDefaults_Box(`);
    });

    it("should create boxed variable for defineModel with options", () => {
      const { result } = parseVueSFC(`
const model = defineModel<string>('title', { required: true })
`);

      expect(result).toContain(`${PREFIX}title_defineModel_Boxed`);
      expect(result).toContain(`${PREFIX}defineModel_Box(`);
    });
  });

  describe("Prettify wrapper", () => {
    it("should wrap defineProps type with Prettify", () => {
      const { result } = parseVueSFC(`
const props = defineProps<{ msg: string }>()
`);

      // The type alias should be wrapped with Prettify
      expect(result).toMatch(new RegExp(`type ${PREFIX}defineProps_Type=.*${PREFIX}Prettify`));
    });

    it("should wrap defineEmits type with Prettify", () => {
      const { result } = parseVueSFC(`
const emit = defineEmits<{ change: [value: string] }>()
`);

      expect(result).toContain(`${PREFIX}Prettify`);
    });

    it("should wrap defineModel type with Prettify", () => {
      const { result } = parseVueSFC(`
const model = defineModel<string>()
`);

      expect(result).toContain(`${PREFIX}Prettify`);
    });
  });

  describe("type reference in macro call", () => {
    it("defineProps should use type alias as generic parameter", () => {
      const { result } = parseVueSFC(`
const props = defineProps<{ msg: string }>()
`);

      // The actual defineProps call should use the type alias
      expect(result).toContain(`defineProps<${PREFIX}defineProps_Type>()`);
    });

    it("defineEmits should use type alias as generic parameter", () => {
      const { result } = parseVueSFC(`
const emit = defineEmits<{ change: [value: string] }>()
`);

      expect(result).toContain(`defineEmits<${PREFIX}defineEmits_Type>()`);
    });

    it("defineModel should use type alias as generic parameter", () => {
      const { result } = parseVueSFC(`
const model = defineModel<string>()
`);

      expect(result).toContain(`defineModel<${PREFIX}modelValue_defineModel_Type>`);
    });
  });

  describe("macro binding tracking", () => {
    it("should track props macro binding correctly", () => {
      const { context } = parseVueSFC(`
const props = defineProps<{ msg: string }>()
`);

      const macroBinding = context.items.find(
        (item: any) => item.type === "macro-binding" && item.macro === "defineProps"
      );

      expect(macroBinding).toBeDefined();
      expect(macroBinding.name).toBe("props");
      expect(macroBinding.isType).toBe(true);
      expect(macroBinding.typeName).toBe(`${PREFIX}defineProps_Type`);
      expect(macroBinding.valueName).toBe("props");
    });

    it("should track emits macro binding correctly", () => {
      const { context } = parseVueSFC(`
const emit = defineEmits<{ change: [] }>()
`);

      const macroBinding = context.items.find(
        (item: any) => item.type === "macro-binding" && item.macro === "defineEmits"
      );

      expect(macroBinding).toBeDefined();
      expect(macroBinding.name).toBe("emit");
      expect(macroBinding.isType).toBe(true);
      expect(macroBinding.typeName).toBe(`${PREFIX}defineEmits_Type`);
    });

    it("should track model macro binding correctly", () => {
      const { context } = parseVueSFC(`
const model = defineModel<string>()
`);

      const defineModel = context.items.find(
        (item: any) => item.type === "define-model"
      );

      expect(defineModel).toBeDefined();
      expect(defineModel.name).toBe("modelValue");
      expect(defineModel.varName).toBe("model");
      expect(defineModel.isType).toBe(true);
      expect(defineModel.typeName).toBe(`${PREFIX}modelValue_defineModel_Type`);
    });

    it("should track object props with objectName", () => {
      const { context } = parseVueSFC(`
const props = defineProps({ foo: String })
`);

      const macroBinding = context.items.find(
        (item: any) => item.type === "macro-binding" && item.macro === "defineProps"
      );

      expect(macroBinding).toBeDefined();
      expect(macroBinding.isType).toBe(false);
      expect(macroBinding.objectName).toBe(`${PREFIX}defineProps_Boxed`);
      expect(macroBinding.typeName).toBeUndefined();
    });
  });

  describe("macro return tracking", () => {
    it("should include props in macro return", () => {
      const { context } = parseVueSFC(`
const props = defineProps<{ msg: string }>()
`);

      const macroReturn = context.items.find(
        (item: any) => item.type === "macro-return"
      );

      expect(macroReturn).toBeDefined();
      expect(macroReturn.content).toContain("props");
      expect(macroReturn.content).toContain('"type"');
    });

    it("should include emits in macro return", () => {
      const { context } = parseVueSFC(`
const emit = defineEmits<{ change: [] }>()
`);

      const macroReturn = context.items.find(
        (item: any) => item.type === "macro-return"
      );

      expect(macroReturn).toBeDefined();
      expect(macroReturn.content).toContain("emits");
    });

    it("should include model in macro return", () => {
      const { context } = parseVueSFC(`
const model = defineModel<string>()
`);

      const macroReturn = context.items.find(
        (item: any) => item.type === "macro-return"
      );

      expect(macroReturn).toBeDefined();
      expect(macroReturn.content).toContain("model");
      expect(macroReturn.content).toContain("modelValue");
    });

    it("should include multiple models in macro return", () => {
      const { context } = parseVueSFC(`
const firstName = defineModel<string>('firstName')
const lastName = defineModel<string>('lastName')
`);

      const macroReturn = context.items.find(
        (item: any) => item.type === "macro-return"
      );

      expect(macroReturn).toBeDefined();
      expect(macroReturn.content).toContain("firstName");
      expect(macroReturn.content).toContain("lastName");
    });

    it("should not include model key when no defineModel is used", () => {
      const { context } = parseVueSFC(`
const props = defineProps<{ msg: string }>()
`);

      const macroReturn = context.items.find(
        (item: any) => item.type === "macro-return"
      );

      expect(macroReturn).toBeDefined();
      // model key should only be present if defineModel is used
      expect(macroReturn.content).not.toContain("model:{");
    });
  });

  describe("edge cases", () => {
    it("should handle empty defineProps", () => {
      const { result } = parseVueSFC(`
const props = defineProps()
`);

      const sourceFile = parseTypeScript(result);
      const errors = hasSyntaxErrors(sourceFile);
      
      expect(errors).toHaveLength(0);
      // No type alias should be created for empty defineProps
      expect(result).not.toContain(`type ${PREFIX}defineProps_Type`);
    });

    it("should handle empty defineEmits", () => {
      const { result } = parseVueSFC(`
const emit = defineEmits()
`);

      const sourceFile = parseTypeScript(result);
      const errors = hasSyntaxErrors(sourceFile);
      
      expect(errors).toHaveLength(0);
    });

    it("should handle defineSlots with type", () => {
      const { result } = parseVueSFC(`
const slots = defineSlots<{
  default: (props: { msg: string }) => any
  header: () => any
}>()
`);

      const sourceFile = parseTypeScript(result);
      const errors = hasSyntaxErrors(sourceFile);
      
      expect(errors).toHaveLength(0);
      expect(result).toContain(`${PREFIX}defineSlots_Type`);
    });

    it("should handle defineExpose with type", () => {
      const { result } = parseVueSFC(`
defineExpose<{ focus: () => void }>()
`);

      const sourceFile = parseTypeScript(result);
      const errors = hasSyntaxErrors(sourceFile);
      
      expect(errors).toHaveLength(0);
    });

    it("should handle destructured defineProps", () => {
      const { result, context } = parseVueSFC(`
const { foo, bar } = defineProps<{ foo: string; bar: number }>()
`);

      const sourceFile = parseTypeScript(result);
      const errors = hasSyntaxErrors(sourceFile);
      
      expect(errors).toHaveLength(0);
    });
  });

  describe("helper types availability", () => {
    it("should import Prettify helper", () => {
      const { context } = parseVueSFC(`
const props = defineProps<{ msg: string }>()
`);

      // Helper imports are from "$verter/types$"
      const prettifyImport = context.items.find(
        (item: any) => 
          item.type === "import" && 
          item.from === "$verter/types$" &&
          item.items.some((i: any) => i.name === "Prettify")
      );

      expect(prettifyImport).toBeDefined();
    });

    it("should import defineProps_Box helper for object syntax", () => {
      const { context } = parseVueSFC(`
const props = defineProps({ foo: String })
`);

      const boxImport = context.items.find(
        (item: any) => 
          item.type === "import" && 
          item.from === "$verter/types$" &&
          item.items.some((i: any) => i.name === "defineProps_Box")
      );

      expect(boxImport).toBeDefined();
    });

    it("should import defineEmits_Box helper for array syntax", () => {
      const { context } = parseVueSFC(`
const emit = defineEmits(['change'])
`);

      const boxImport = context.items.find(
        (item: any) => 
          item.type === "import" && 
          item.from === "$verter/types$" &&
          item.items.some((i: any) => i.name === "defineEmits_Box")
      );

      expect(boxImport).toBeDefined();
    });

    it("should import defineModel_Box helper", () => {
      const { context } = parseVueSFC(`
const model = defineModel<string>('title', { required: true })
`);

      const boxImport = context.items.find(
        (item: any) => 
          item.type === "import" && 
          item.from === "$verter/types$" &&
          item.items.some((i: any) => i.name === "defineModel_Box")
      );

      expect(boxImport).toBeDefined();
    });
  });

  describe("import tracking", () => {
    it("should add vue imports for macros", () => {
      const { context } = parseVueSFC(`
const props = defineProps<{ msg: string }>()
`);

      const vueImport = context.items.find(
        (item: any) => item.type === "import" && item.from === "vue"
      );

      expect(vueImport).toBeDefined();
      expect(vueImport.items).toContainEqual(
        expect.objectContaining({ name: "defineProps" })
      );
    });

    it("should add vue imports for multiple macros", () => {
      const { context } = parseVueSFC(`
const props = defineProps<{ msg: string }>()
const emit = defineEmits<{ change: [] }>()
const model = defineModel<string>()
`);

      const vueImports = context.items.filter(
        (item: any) => item.type === "import" && item.from === "vue"
      );

      expect(vueImports.length).toBeGreaterThan(0);
      
      const allImportedItems = vueImports.flatMap((i: any) => i.items.map((x: any) => x.name));
      expect(allImportedItems).toContain("defineProps");
      expect(allImportedItems).toContain("defineEmits");
      expect(allImportedItems).toContain("defineModel");
    });
  });

  describe("shared fixtures validation", () => {
    // Test all fixtures for syntax validity
    describe("syntax validation for all fixtures", () => {
      for (const fixture of fixtures) {
        it(`should generate syntactically valid TypeScript for: ${fixture.name}`, () => {
          const { result } = parseVueSFC(fixture.code);
          const sourceFile = parseTypeScript(result);
          const errors = hasSyntaxErrors(sourceFile);
          
          if (errors.length > 0) {
            console.log(`Fixture: ${fixture.name}`);
            console.log("Syntax errors:", errors.map(e => e.messageText));
            console.log("Generated code:", result);
          }
          
          expect(errors).toHaveLength(0);
        });
      }
    });

    // Test fixtures with expectations
    describe("pattern expectations", () => {
      for (const fixture of fixtures) {
        if (!fixture.expectations) continue;

        describe(fixture.name, () => {
          const { result } = parseVueSFC(fixture.code);

          if (fixture.expectations?.typeAliases) {
            for (const typeAlias of fixture.expectations.typeAliases) {
              it(`should create type alias: ${typeAlias}`, () => {
                const sourceFile = parseTypeScript(result);
                const typeAliases = findTypeAliases(sourceFile);
                expect(typeAliases.has(typeAlias)).toBe(true);
              });
            }
          }

          if (fixture.expectations?.boxedVariables) {
            for (const boxedVar of fixture.expectations.boxedVariables) {
              it(`should create boxed variable: ${boxedVar}`, () => {
                const sourceFile = parseTypeScript(result);
                const declarations = findVariableDeclarations(sourceFile);
                expect(declarations.has(boxedVar)).toBe(true);
              });
            }
          }

          if (fixture.expectations?.patterns) {
            for (const pattern of fixture.expectations.patterns) {
              it(`should contain pattern: ${pattern.slice(0, 50)}...`, () => {
                expect(result).toContain(pattern);
              });
            }
          }

          if (fixture.expectations?.antiPatterns) {
            for (const antiPattern of fixture.expectations.antiPatterns) {
              it(`should NOT contain: ${antiPattern.slice(0, 50)}...`, () => {
                expect(result).not.toContain(antiPattern);
              });
            }
          }
        });
      }
    });
  });
});
